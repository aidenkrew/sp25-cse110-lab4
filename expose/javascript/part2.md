1. Since i is a var, which is funciton-scoped, i would display 3 since it incremented to prices.length.
2. I think it would display 150 since we take the last value of prices and do the operation on it.
3. It would also be 150 as the finalPrice is 150 * 100 / 100.
4. Function would return [50, 100, 150] since it looks like the code would work as its intended going through the for loop 3 times and pushing 3 values into discounted.
5. It would cause an error since we said let i so there is no i variable outside of the loop.
6. Since discountedprice was defined using let, there isn't a discountedprice outside of the loop so it is an error.
7. It is going to display 150 since it was declared outside of the for loop.
8. It should return [50, 100, 150] again since all of the work is done inside the forloop and nothing wrong seems out of the ordinary.
9. It would cause an error since we said let i so there is no i variable outside of the loop.
10. It would display 3 since that is the value that it was assigned at declaration.
11. It should return [50, 100, 150] again, discounted shouldn't have an error because you are pushing values instead of reassigning it.
12. a.student.name
    b.student["Grad Year"]
    c.student.greeting()
    d.student["Favorite Teacher"].name
    e.student.courseLoad[0]
13. a. '32' since it would join the strings together.
    b. 1 since the - operator forces the '3' into an int.
    c. 3 since the null is treated as a 0 since the 3 is an int.
    d. '3null' again since the strings are joined together.
    e. True acts like a 1 so it is 4.
    f. 0 since false and null act like 0.
    g. '3undefined', strings are joined together since '3' is a string.
    h. NAN since undefined doens't have an int value.

14. a.True since 2 will be converted to int and 2>1
    b. False since both are ints, it will compare lexicographically and '2' > '1'
    c. True, '2' is converted to an int and 2 == 2.
    d. False since === does not convert and int vs string is not equal. 
    e. False since true is converted to 1 and 2 != 1.
    f. True since both sides of the equation return true.
15. == allows values to be modified with type coercion but === does not.
17. It looks like it returns [2,4,6] since callback(array[i]) multiplies the array[i] by 2.
19.  1 4 3 2

  
    
    
